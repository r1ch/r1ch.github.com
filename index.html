<!DOCTYPE html>
<html lang="en">
    <head>
        <title>bradi.sh</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="Homepage for bradi.sh">
        <script src="https://d3js.org/d3.v6.min.js"></script>
    </head>
    <body>
        <div id = "svg"></div>
        <script type = "application/javascript">

            const margin = {top: 0, right: 0, bottom: 0, left: 0};
            const width = 400 - margin.left - margin.right;
            const height = 880 - margin.top - margin.bottom;

            const TILE_SIZE = 80
            const TILES_PER_ROW = Math.ceil(width/TILE_SIZE)
            const TILES_PER_COLUMN = Math.ceil(height/TILE_SIZE)

            const COLOURS = [
                "#FFF4E0", 
                "#F8B501",
                "#06ACB5",
                "#17191D",
                "#FC3D3C"
            ]

            const PAINT_LOCATIONS = {
                TOP_LEFT_CORNER: 0,
                TOP_RIGHT_CORNER: 1,
                BOTTOM_RIGHT_CORNER: 2,
                BOTTOM_LEFT_CORNER: 3,
                CENTER: 4,
                BASE:5,
                TEXT:6
            }

            const N_PAINT_LOCATIONS = Object.keys(PAINT_LOCATIONS).length

            const CORNERS = [
                PAINT_LOCATIONS.TOP_LEFT_CORNER,
                PAINT_LOCATIONS.TOP_RIGHT_CORNER,
                PAINT_LOCATIONS.BOTTOM_RIGHT_CORNER,
                PAINT_LOCATIONS.BOTTOM_LEFT_CORNER
            ]

            const CHANCE = {
                ofRecolour : 0.1,
                ofRecircle : 0.1,
                ofRerotate : 0.01,
                ofHavingACenter: 0.75,
                ofOffCorners : 0.1,
                ofIgnoringNeighbours: 0.2,
            }

            const TEXT = [["b","r"],[,"a","d","i"],[,,"\u00b7","s","h"]]
            const findText = (x,y)=>(TEXT[y] || [])[x] || false

            class Tile{
                constructor(ix,iy){
                    this._ix = ix
                    this._iy = iy
                    this._x = this.ix*TILE_SIZE;
                    this._y = this.iy*TILE_SIZE;
                    this._neighbours = [
                        //up 
                        this.ix + TILES_PER_ROW * ((this.iy-1+TILES_PER_COLUMN)%TILES_PER_COLUMN),
                        //down
                        this.ix + TILES_PER_ROW * ((this.iy+1+TILES_PER_COLUMN)%TILES_PER_COLUMN),
                        //left
                        (this.ix-1+TILES_PER_ROW)%TILES_PER_ROW + TILES_PER_ROW*this.iy,
                        //right
                        (this.ix+1+TILES_PER_ROW)%TILES_PER_ROW + TILES_PER_ROW*this.iy
                    ]
                    this._cx = this._cy = TILE_SIZE/2
                    this._index = this.iy * TILES_PER_ROW + this.ix
                    this.rerotate()
                    this.recircle(true)
                    this.recolour(true)
                    this._text = findText(this.ix,this.iy)
                    this._clicked = false
                    if(this.text){
                        this._rotation = 0
                        this.fixTextColour()
                    }
                }

                tickle(force=false){
                    if(force || Math.random()<CHANCE.ofRecolour) this.recolour()
                    if(force || Math.random()<CHANCE.ofRecircle) this.recircle()
                    if(force || Math.random()<CHANCE.ofRerotate) this.rerotate()
                    this.text && this.fixTextColour()
                }

                recircle(noOffCorners=false){
                    this._centerCircleRadius = Math.random() < CHANCE.ofHavingACenter ? TILE_SIZE/2*Math.SQRT2*(Math.random() * 0.1 + 0.15) : 0
                    this._cornerCircleRadius = TILE_SIZE/2
                    //prefer diagonal pairs, but allow switching
                    this._corners = Math.random() > 0.5 ? [1,0,1,0] : [0,1,0,1]
                    //now flick some on at random
                    if(!noOffCorners) this._corners = this._corners.map(corner=>Math.random()<CHANCE.ofOffCorners ? 1-corner : corner)
                }

                recolour(ignoreNeighbours=false){
                    const chosenNeighbour = Math.random()*this.neighbours.length|0
                    if(!ignoreNeighbours && Math.random()>CHANCE.ofIgnoringNeighbours){
                        this._colours = this._colours.map((colour,index) => Math.random()>0.5 ? tiles[this.neighbours[chosenNeighbour]].colours[index] : colour)
                    } else {
                        this._colours = Array(N_PAINT_LOCATIONS).fill(0).map(_=>COLOURS[Math.random()*COLOURS.length|0])
                    }
                }

                rerotate(){
                    this._rotation = [-180,-90,0,90,180][Math.random()*5|0]
                }

                fixTextColour(){
                    if(this.colours[PAINT_LOCATIONS.TEXT] == this.colours[this.centerCircleRadius > 0 ? PAINT_LOCATIONS.CENTER : PAINT_LOCATIONS.BASE]){
                        this._colours[PAINT_LOCATIONS.TEXT] = COLOURS.find(entry=>this.colours[this.centerCircleRadius>0 ? PAINT_LOCATIONS.CENTER : PAINT_LOCATIONS.BASE]!=entry)
                    }
                }


                click(){
                    if(!this._clicked){
                        this.tickle(true)
                        return this._clicked = true
                    } else return false
                }

                done(){
                    this._clicked = false
                }

                get neighbours(){
                    return this._neighbours
                }

                get clicked(){
                    return this._clicked
                }

                get text(){
                    return this._text
                }

                get ix(){
                    return this._ix
                }

                get iy(){
                    return this._iy
                }

                get x(){
                    return this._x
                }

                get y(){
                    return this._y
                }

                get cx(){
                    return this._cx
                }

                get cy(){
                    return this._cy
                }

                get index(){
                    return this._index
                }

                get cornerCircleRadius(){
                    return this._cornerCircleRadius
                }

                get centerCircleRadius(){
                    return this._centerCircleRadius
                }

                get colours(){
                    return this._colours
                }

                get rotation(){
                    return this._rotation
                }

                get corners(){
                    return [
                        (radius=>`M${radius},0A${radius},${radius},0,0,1,0,${radius}L0,0Z`)(this._corners[0] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE},${radius}A${radius},${radius},0,0,1,${TILE_SIZE-radius},0L${TILE_SIZE},0Z`)(this._corners[1] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE-radius},${TILE_SIZE}A${radius},${radius},0,0,1,${TILE_SIZE},${TILE_SIZE-radius}L${TILE_SIZE},${TILE_SIZE}Z`)(this._corners[2] * this.cornerCircleRadius),
                        (radius=>`M0,${TILE_SIZE-radius}A${radius},${radius},0,0,1,${radius},${TILE_SIZE}L0,${TILE_SIZE}Z`)(this._corners[3] * this.cornerCircleRadius)
                    ]
                }

                get arcs(){
                    return [
                        (radius=>`M${radius},0A${radius},${radius},0,0,1,0,${radius}`)(this._corners[0] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE},${radius}A${radius},${radius},0,0,1,${TILE_SIZE-radius},0`)(this._corners[1] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE-radius},${TILE_SIZE}A${radius},${radius},0,0,1,${TILE_SIZE},${TILE_SIZE-radius}`)(this._corners[2] * this.cornerCircleRadius),
                        (radius=>`M0,${TILE_SIZE-radius}A${radius},${radius},0,0,1,${radius},${TILE_SIZE}`)(this._corners[3] * this.cornerCircleRadius)
                    ]
                }

            }

            const tiles = []
            for(let y=0;y<height/TILE_SIZE;y++){
                for(let x=0;x<width/TILE_SIZE;x++){
                    tiles.push(new Tile(x,y))
                }
            }

            const clickHandler = function(d,i){
                tiles[i.index].click() && redraw(i.index)
            }
            
            const svg = d3
                .selectAll("#svg")
                .append("svg")
                .attr("viewBox", [0, 0, width, height]);

            const theTiles = svg
                .append("g")
                .attr("id","theTiles")

            const tileTranslations = theTiles
                .selectAll(".tileTranslations")
                .data(tiles,d=>d.index)
                .enter()
                .append("g")
                .attr("transform",d=>`translate(${d.x},${d.y})`)
                .attr("class","tileTranslations")
                .on('click', clickHandler);

            const tileOffsets = tileTranslations
                .append("g")
                .attr("transform",d=>`translate(${TILE_SIZE/2},${TILE_SIZE/2})`)

            const tileRotations = tileOffsets
                .append("g")
                .attr("transform",d=>`rotate(${d.rotation})`)

            const tileGroups = tileRotations
                .append("g")
                .attr("transform",d=>`translate(${TILE_SIZE/-2},${TILE_SIZE/-2})`)
                .attr("class","tileTranslations")

            const bases = tileGroups
                .append("rect")
                .attr("width",TILE_SIZE)
                .attr("height",TILE_SIZE)
                .attr("x",0)
                .attr("y",0)
                .attr("fill",d=>d.colours[PAINT_LOCATIONS.BASE])
                .attr("stroke","none")

            const corners = CORNERS.map(corner=>tileGroups
                .append("path")
                .attr("d",d=>d.corners[corner])
                .attr("fill",d=>d.colours[corner])
                .attr("stroke","none")
            )

            const arcs = CORNERS.map(arc=>tileGroups
                .append("path")
                .attr("d",d=>d.arcs[arc])
                .attr("fill","none")
                .attr("stroke","white")
            )

            const centers = tileGroups
                .append("circle")
                .attr("r",d=>d.centerCircleRadius)
                .attr("cx",d=>d.cx)
                .attr("cy",d=>d.cy)
                .attr("fill",d=>d.colours[PAINT_LOCATIONS.CENTER])

            const text = tileGroups
                .filter(d=>d.text)
                .append("text")
                .attr("alignment-baseline","central")
                .attr("text-anchor","middle")
                .attr("font-family","sans-serif")
                .attr("font-weight","bold")
                .attr("x",TILE_SIZE/2)
                .attr("y",TILE_SIZE/2)
                .attr("fill",d=>d.colours[PAINT_LOCATIONS.TEXT])
                .attr("font-size",`${TILE_SIZE/4}px`)
                .text(d=>d.text)
            
            const redraw = tileIndex =>{
                let all = tileIndex ? false : true

                tileRotations
                    .filter(d=>(all&&!d.clicked)||d.index==tileIndex)
                    .transition()
                    .duration(2000)
                    .attr("transform",d=>`rotate(${d.rotation})`)
                    .on("end",d=>d.done())

                bases
                    .filter(d=>(all&&!d.clicked)||d.index==tileIndex)
                    .transition()
                    .duration(2000)
                    .attr("fill",d=>d.colours[PAINT_LOCATIONS.BASE])

                centers
                    .filter(d=>(all&&!d.clicked)||d.index==tileIndex)
                    .transition()
                    .duration(2000)
                    .attr("r",d=>d.centerCircleRadius)
                    .attr("cx",d=>d.cx)
                    .attr("cy",d=>d.cy)
                    .attr("fill",d=>d.colours[PAINT_LOCATIONS.CENTER])

                arcs
                    .filter(d=>(all&&!d.clicked)||d.index==tileIndex)
                    .forEach((arc,index)=>{
                        arc
                        .transition()
                        .duration(2000)
                        .attr("d",d=>d.arcs[index])
                    })

                corners
                    .filter(d=>(all&&!d.clicked)||d.index==tileIndex)
                    .forEach((corner,index)=>{
                        corner
                        .transition()
                        .duration(2000)
                        .attr("d",d=>d.corners[index])
                        .attr("fill",d=>d.colours[index])
                    })

                text
                    .transition()
                    .duration(2000)
                    .attr("fill",d=>d.colours[PAINT_LOCATIONS.TEXT])
            }

            setInterval(()=>{
                tiles.forEach(tile=>tile.tickle())
                redraw()
            },2500)
        </script>
    </body>
</html>
