<!DOCTYPE html>
<html>
    <head>
        <script src="https://d3js.org/d3.v6.min.js"></script>
    </head>
    <body>
        <div id = "svg"></div>
        <script type = "application/javascript">

            const margin = {top: 0, right: 0, bottom: 0, left: 0};
            const width = 400 - margin.left - margin.right;
            
            const height = 880 - margin.top - margin.bottom;

            const TILE_SIZE = 80
            const COLOURS = [
                "#FFF4E0", 
                "#F8B501",
                "#06ACB5",
                "#17191D",
                "#FC3D3C"
            ]

            const TEXT = [["b","r"],[,"a","d","i"],[,,,"s","h"]]
            const findText = (x,y)=>(TEXT[y/TILE_SIZE] || [])[x/TILE_SIZE] || false

            class Tile{
                constructor(x,y,parent){
                    this._x = x;
                    this._y = y;
                    this._parent = parent ? parent : this;
                    this._cx = this._cy = TILE_SIZE/2
                    this._index = this.y + this.x/TILE_SIZE
                    this.rerotate()
                    this.recircle()
                    this.recolour()
                    this._text = findText(x,y)
                    if(this.text) this._rotation = 0
                }



                tickle(){
                    if(Math.random()>0.95) this.recolour()
                    if(Math.random()>0.95) this.recircle()
                    if(Math.random()>0.99) this.rerotate()
                }

                recircle(){
                    this._centerCircleRadius = Math.random() > 0.5 ? TILE_SIZE/2*Math.SQRT2*(Math.random() * 0.125 + 0.125) : 0
                    this._cornerCircleRadius = TILE_SIZE/2
                    this._corners = Array(4).fill(0).map(_=>Math.random()>0.5?1:0)
                }

                recolour(){
                    this._colours = Array(6).fill(0).map(_=>COLOURS[Math.random()*COLOURS.length|0])
                    this._colours = this._colours.map((colour,index)=>Math.random()>0.3?this.parent.colours[index]:colour)
                }

                rerotate(){
                    this._rotation = [0,90,180,270][Math.random()*4|0]
                }

                get text(){
                    return this._text
                }

                get parent(){
                    return this._parent
                }

                get x(){
                    return this._x
                }

                get y(){
                    return this._y
                }

                get cx(){
                    return this._cx
                }

                get cy(){
                    return this._cy
                }

                get index(){
                    return this._index
                }

                get cornerCircleRadius(){
                    return this._cornerCircleRadius
                }

                get centerCircleRadius(){
                    return this._centerCircleRadius
                }

                get colours(){
                    return this._colours
                }

                get rotation(){
                    return this._rotation
                }

                get corners(){
                    return [
                        (radius=>`M ${radius}           0                   A ${radius} ${radius} 0 0 1 0                   ${radius}           L 0             0               Z`)(this._corners[0] * this.cornerCircleRadius),
                        (radius=>`M ${TILE_SIZE}        ${radius}           A ${radius} ${radius} 0 0 1 ${TILE_SIZE-radius} 0                   L ${TILE_SIZE}  0               Z`)(this._corners[1] * this.cornerCircleRadius),
                        (radius=>`M ${TILE_SIZE-radius} ${TILE_SIZE}        A ${radius} ${radius} 0 0 1 ${TILE_SIZE}        ${TILE_SIZE-radius} L ${TILE_SIZE}  ${TILE_SIZE}    Z`)(this._corners[2] * this.cornerCircleRadius),
                        (radius=>`M 0                   ${TILE_SIZE-radius} A ${radius} ${radius} 0 0 1 ${radius}           ${TILE_SIZE}        L 0             ${TILE_SIZE}    Z`)(this._corners[3] * this.cornerCircleRadius)
                    ]
                }

                get arcs(){
                    return [
                        (radius=>`M ${radius}           0                   A ${radius} ${radius} 0 0 1 0                   ${radius}          `)(this._corners[0] * this.cornerCircleRadius),
                        (radius=>`M ${TILE_SIZE}        ${radius}           A ${radius} ${radius} 0 0 1 ${TILE_SIZE-radius} 0                  `)(this._corners[1] * this.cornerCircleRadius),
                        (radius=>`M ${TILE_SIZE-radius} ${TILE_SIZE}        A ${radius} ${radius} 0 0 1 ${TILE_SIZE}        ${TILE_SIZE-radius}`)(this._corners[2] * this.cornerCircleRadius),
                        (radius=>`M 0                   ${TILE_SIZE-radius} A ${radius} ${radius} 0 0 1 ${radius}           ${TILE_SIZE}       `)(this._corners[3] * this.cornerCircleRadius)
                    ]
                }

            }

            const tiles = []
            let x=y=0
            let last = root = new Tile(x,y)
            for(let y=0;y<height;y=y+TILE_SIZE){
                let head = new Tile(x,y)
                for(let x=0;x<width;x=x+TILE_SIZE){
                    let current = new Tile(x,y,[root,head,last][Math.random()*3|0])
                    tiles.push(current)
                    last=current
                }
            }

            const clickHandler = function(d,i){
                console.log(this)
                console.log(d)
                console.log(i.tickle())
                i.tickle()
            }
            
            const svg = d3
                .selectAll("#svg")
                .append("svg")
                .attr("viewBox", [0, 0, width, height]);

            const defs = svg
                .append("defs")

            let maxSize = 0
            let maxHeight = 0
            let maxWidth = 0
            let victim
            const clipPaths = defs
                .selectAll("clipPath")
                .data(TEXT.join().split(","))
                .enter()
                .append("clipPath")
                .attr("id",d=>`letter-clip-${d}`)
                .append("text")
                .attr("x",TILE_SIZE/2)
                .attr("y",TILE_SIZE/2)
                .attr("alignment-baseline","central")
                .attr("text-anchor","middle")
                .text(d=>d)
                .attr("font-size", function(d) {
                    victim=this;
                    console.log(this);
                    maxSize=Math.max(maxSize,this.getComputedTextLength());
                    maxWidth=Math.max(maxWidth,this.getBBox().width)
                    maxHeight=Math.max(maxHeight,this.getBBox().height)
                    return (TILE_SIZE / this.getComputedTextLength() * 12) + "px"; }
                )
                .attr("font-family","sans-serif")
                .attr("font-weight","bold")
            
                maxSize = Math.max(maxHeight,maxWidth,maxSize)

            clipPaths
                .attr("font-size",`${TILE_SIZE/maxSize*20}px`)

            const theTiles = svg
                .append("g")
                .attr("id","theTiles")

            const tileTranslations = theTiles
                .selectAll(".tileTranslations")
                .data(tiles,d=>d.index)
                .enter()
                .append("g")
                .attr("transform",d=>`translate(${d.x},${d.y})`)
                .attr("class","tileTranslations")
                .on('click', clickHandler);

            const tileOffsets = tileTranslations
                .append("g")
                .attr("transform",d=>`translate(${TILE_SIZE/2},${TILE_SIZE/2})`)

            const tileRotations = tileOffsets
                .append("g")
                .attr("transform",d=>`rotate(${d.rotation})`)

            const tileGroups = tileRotations
                .append("g")
                .attr("transform",d=>`translate(${TILE_SIZE/-2},${TILE_SIZE/-2})`)
                .attr("class","tileTranslations")

            const clips = tileGroups
                .filter(d=>d.text)
                .attr("clip-path",d=>`url(#letter-clip-${d.text})`)

            const bases = tileGroups
                .append("rect")
                .attr("width",TILE_SIZE)
                .attr("height",TILE_SIZE)
                .attr("x",0)
                .attr("y",0)
                .attr("fill",d=>d.colours[5])
                .attr("stroke","none")

            const corners = [0,1,2,3].map(corner=>tileGroups
                .append("path")
                .attr("d",d=>d.corners[corner])
                .attr("fill",d=>d.colours[corner])
                .attr("stroke","none")
            )

            const arcs = [0,1,2,3].map(arc=>tileGroups
                .append("path")
                .attr("d",d=>d.arcs[arc])
                .attr("fill","none")
                .attr("stroke","white")
            )

            const centers = tileGroups
                .append("circle")
                .attr("r",d=>d.centerCircleRadius)
                .attr("cx",d=>d.cx)
                .attr("cy",d=>d.cy)
                .attr("fill",d=>d.colours[4])

            setInterval(()=>{
                tiles.forEach(tile=>tile.tickle())

                tileRotations
                    .transition()
                    .duration(2000)
                    .attr("transform",d=>`rotate(${d.rotation})`)

                bases
                    .transition()
                    .duration(2000)
                    .attr("fill",d=>d.colours[5])

                centers
                    .transition()
                    .duration(2000)
                    .attr("r",d=>d.centerCircleRadius)
                    .attr("cx",d=>d.cx)
                    .attr("cy",d=>d.cy)
                    .attr("fill",d=>d.colours[4])

                arcs.forEach((arc,index)=>{
                    arc
                    .transition()
                    .duration(2000)
                    .attr("d",d=>d.arcs[index])
                })

                corners.forEach((corner,index)=>{
                    corner
                    .transition()
                    .duration(2000)
                    .attr("d",d=>d.corners[index])
                })

            },2500)
        </script>
    </body>
</html>
