<!DOCTYPE html>
<html lang="en">
    <head>
        <title>bradi.sh</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="Homepage for bradi.sh">
        <script src="https://d3js.org/d3.v6.min.js"></script>
    </head>
    <body>
        <div id = "svg" ></div>
        <script type = "application/javascript">

            const margin = {top: 0, right: 0, bottom: 0, left: 0};
            const width = window.innerWidth - margin.left - margin.right;
            const height = window.innerHeight - margin.top - margin.bottom;

            const TILE_SIZE = 80
            const TILES_PER_ROW = Math.ceil(width/TILE_SIZE) + 2
            const TILES_PER_COLUMN = Math.ceil(height/TILE_SIZE) + 2
            
            let cameraX = 0;
            let cameraY = 0;
            let targetCameraX = 0;
            let targetCameraY = 0;

            const COLOURS = [
                "#FFF4E0", 
                "#F8B501",
                "#06ACB5",
                "#17191D",
                "#FC3D3C"
            ]

            const PAINT_LOCATIONS = {
                TOP_LEFT_CORNER: 0,
                TOP_RIGHT_CORNER: 1,
                BOTTOM_RIGHT_CORNER: 2,
                BOTTOM_LEFT_CORNER: 3,
                CENTER: 4,
                BASE:5,
                TEXT:6
            }

            const N_PAINT_LOCATIONS = Object.keys(PAINT_LOCATIONS).length

            const CORNERS = [
                PAINT_LOCATIONS.TOP_LEFT_CORNER,
                PAINT_LOCATIONS.TOP_RIGHT_CORNER,
                PAINT_LOCATIONS.BOTTOM_RIGHT_CORNER,
                PAINT_LOCATIONS.BOTTOM_LEFT_CORNER
            ]

            const CHANCE = {
                ofRecolour : 0.1,
                ofRecircle : 0.1,
                ofRerotate : 0.01,
                ofHavingACenter: 0.75,
                ofOffCorners : 0.1,
                ofIgnoringNeighbours: 0.2,
            }

            const TEXT = [["b","r"],[,"a","d","i"],[,,"\u00b7","s","h"]]
            const findText = (x,y)=>{
                // Calculate wrapped coordinates relative to the TEXT array
                // We use a large offset to handle negative numbers correctly before modulo
                // Assuming TEXT should repeat or be placed relative to 0,0
                // For now, let's just make it repeat every TILES_PER_ROW/COLUMN to keep it simple and consistent
                // However, TEXT is small. If we want it to just appear once near 0,0 and repeat:
                // Let's use the grid size as the repetition period.
                let wrappedX = ((x % TILES_PER_ROW) + TILES_PER_ROW) % TILES_PER_ROW;
                let wrappedY = ((y % TILES_PER_COLUMN) + TILES_PER_COLUMN) % TILES_PER_COLUMN;
                return (TEXT[wrappedY] || [])[wrappedX] || false
            }
            // URL array is missing, so findURL will fail or return false if URL is global window.URL
            // Disabling it for now to prevent errors
            const findURL = (x,y)=> false 

            class Tile{
                constructor(ix,iy){
                    this._dirty = true;
                    this.init(ix, iy)
                }

                init(ix, iy) {
                    this._ix = ix
                    this._iy = iy
                    // For finding neighbours in the physical grid array, we need to map logical coordinates
                    // back to the array index 0..N.
                    // However, neighbours logic in original code was based on fixed grid wrapping.
                    // For infinite scroll, "neighbours" are logically adjacent tiles.
                    // We'll simplify and remove neighbour-based coloring logic for now or adapt it.
                    // The original neighbour logic was:
                    // this.ix + TILES_PER_ROW * ((this.iy-1+TILES_PER_COLUMN)%TILES_PER_COLUMN)
                    // This refers to indices in the `tiles` array.
                    // Since we are recycling, the `tiles` array doesn't map perfectly to logical space anymore.
                    // We'll just use random colors for now to simplify infinite scrolling transition.
                    this._neighbours = [] 

                    this._cx = this._cy = TILE_SIZE/2
                    this._index = (this.iy % TILES_PER_COLUMN + TILES_PER_COLUMN) % TILES_PER_COLUMN * TILES_PER_ROW + (this.ix % TILES_PER_ROW + TILES_PER_ROW) % TILES_PER_ROW
                    
                    this.rerotate()
                    this.recircle(true)
                    this.recolour(true) // force true to ignore neighbours logic which is broken in infinite scroll
                    this._text = findText(this.ix,this.iy)
                    this._url = findURL(this.ix,this.iy)
                    this._clicked = false
                    if(this.text){
                        this._rotation = 0
                        this.fixTextColour()
                    }
                    this._dirty = true;
                }

                tickle(force=false){
                    if(force || Math.random()<CHANCE.ofRecolour) {
                        this.recolour();
                        this._dirty = true;
                    }
                    if(force || Math.random()<CHANCE.ofRecircle) {
                        this.recircle();
                        this._dirty = true;
                    }
                    if(force || Math.random()<CHANCE.ofRerotate) {
                        this.rerotate();
                        this._dirty = true;
                    }
                    if(this.text) {
                        this.fixTextColour();
                        this._dirty = true;
                    }
                }

                get dirty(){
                    return this._dirty;
                }

                markClean(){
                    this._dirty = false;
                }

                recircle(noOffCorners=false){
                    this._centerCircleRadius = Math.random() < CHANCE.ofHavingACenter ? TILE_SIZE/2*Math.SQRT2*(Math.random() * 0.1 + 0.15) : 0
                    this._cornerCircleRadius = TILE_SIZE/2
                    //prefer diagonal pairs, but allow switching
                    this._corners = Math.random() > 0.5 ? [1,0,1,0] : [0,1,0,1]
                    //now flick some on at random
                    if(!noOffCorners) this._corners = this._corners.map(corner=>Math.random()<CHANCE.ofOffCorners ? 1-corner : corner)
                }

                recolour(ignoreNeighbours=false){
                    const chosenNeighbour = Math.random()*this.neighbours.length|0
                    if(!ignoreNeighbours && Math.random()>CHANCE.ofIgnoringNeighbours){
                        this._colours = this._colours.map((colour,index) => Math.random()>0.5 ? tiles[this.neighbours[chosenNeighbour]].colours[index] : colour)
                    } else {
                        this._colours = Array(N_PAINT_LOCATIONS).fill(0).map(_=>COLOURS[Math.random()*COLOURS.length|0])
                    }
                }

                rerotate(){
                    this._rotation = [-180,-90,0,90,180][Math.random()*5|0]
                }

                fixTextColour(){
                    if(this.colours[PAINT_LOCATIONS.TEXT] == this.colours[this.centerCircleRadius > 0 ? PAINT_LOCATIONS.CENTER : PAINT_LOCATIONS.BASE]){
                        this._colours[PAINT_LOCATIONS.TEXT] = COLOURS.find(entry=>this.colours[this.centerCircleRadius>0 ? PAINT_LOCATIONS.CENTER : PAINT_LOCATIONS.BASE]!=entry)
                    }
                }


                click(){
                    if(!this._clicked){
                        this.tickle(true)
                        return this._clicked = true
                    } else return false
                }

                done(){
                    this._clicked = false
                }

                get neighbours(){
                    return this._neighbours
                }

                get clicked(){
                    return this._clicked
                }

                get text(){
                    return this._text
                }

                get url(){
                    return this._url
                }

                get ix(){
                    return this._ix
                }

                get iy(){
                    return this._iy
                }

                get x(){
                    return this._ix * TILE_SIZE - cameraX
                }

                get y(){
                    return this._iy * TILE_SIZE - cameraY
                }

                get cx(){
                    return this._cx
                }

                get cy(){
                    return this._cy
                }

                get index(){
                    return this._index
                }

                get cornerCircleRadius(){
                    return this._cornerCircleRadius
                }

                get centerCircleRadius(){
                    return this._centerCircleRadius
                }

                get colours(){
                    return this._colours
                }

                get rotation(){
                    return this._rotation
                }

                get corners(){
                    return [
                        (radius=>`M${radius},0A${radius},${radius},0,0,1,0,${radius}L0,0Z`)(this._corners[0] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE},${radius}A${radius},${radius},0,0,1,${TILE_SIZE-radius},0L${TILE_SIZE},0Z`)(this._corners[1] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE-radius},${TILE_SIZE}A${radius},${radius},0,0,1,${TILE_SIZE},${TILE_SIZE-radius}L${TILE_SIZE},${TILE_SIZE}Z`)(this._corners[2] * this.cornerCircleRadius),
                        (radius=>`M0,${TILE_SIZE-radius}A${radius},${radius},0,0,1,${radius},${TILE_SIZE}L0,${TILE_SIZE}Z`)(this._corners[3] * this.cornerCircleRadius)
                    ]
                }

                get arcs(){
                    return [
                        (radius=>`M${radius},0A${radius},${radius},0,0,1,0,${radius}`)(this._corners[0] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE},${radius}A${radius},${radius},0,0,1,${TILE_SIZE-radius},0`)(this._corners[1] * this.cornerCircleRadius),
                        (radius=>`M${TILE_SIZE-radius},${TILE_SIZE}A${radius},${radius},0,0,1,${TILE_SIZE},${TILE_SIZE-radius}`)(this._corners[2] * this.cornerCircleRadius),
                        (radius=>`M0,${TILE_SIZE-radius}A${radius},${radius},0,0,1,${radius},${TILE_SIZE}`)(this._corners[3] * this.cornerCircleRadius)
                    ]
                }

            }

            const tiles = []
            // Create a grid of tiles large enough to cover the screen plus buffer
            for(let y= -1; y < TILES_PER_COLUMN - 1; y++){
                for(let x= -1; x < TILES_PER_ROW - 1; x++){
                    tiles.push(new Tile(x,y))
                }
            }

            const clickHandler = function(event, d){
                 // d is the data attached to the element
                 if(d.click()) {
                     updateAppearance(d);
                 }
            }
            
            const svg = d3
                .selectAll("#svg")
                .append("svg")
                .attr("viewBox", [0, 0, width, height])
                .style("width", "100%")
                .style("height", "100%")
                .style("display", "block");

            // Scroll handling
            window.addEventListener('wheel', e => {
                e.preventDefault();
                targetCameraX += e.deltaX;
                targetCameraY += e.deltaY;
            }, { passive: false });
            
            // Touch handling
            let touchStartX = 0;
            let touchStartY = 0;
            window.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: false });
            
            window.addEventListener('touchmove', e => {
                e.preventDefault(); // prevent native scroll
                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                targetCameraX -= dx;
                targetCameraY -= dy;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: false });

            const theTiles = svg
                .append("g")
                .attr("id","theTiles")

            const tileTranslations = theTiles
                .selectAll(".tileTranslations")
                .data(tiles,d=>d.index)
                .enter()
                .append("g")
                .append("a")
                .attr("href","https://recipes.bradi.sh/")
                .attr("transform",d=>`translate(${d.x},${d.y})`)
                .attr("class","tileTranslations")
                .on('click', clickHandler);

            const tileOffsets = tileTranslations
                .append("g")
                .attr("transform",d=>`translate(${TILE_SIZE/2},${TILE_SIZE/2})`)

            const tileRotations = tileOffsets
                .append("g")
                .attr("transform",d=>`rotate(${d.rotation})`)

            const tileGroups = tileRotations
                .append("g")
                .attr("transform",d=>`translate(${TILE_SIZE/-2},${TILE_SIZE/-2})`)
                .attr("class","tileTranslations")

            const bases = tileGroups
                .append("rect")
                .attr("width",TILE_SIZE)
                .attr("height",TILE_SIZE)
                .attr("x",0)
                .attr("y",0)
                .attr("fill",d=>d.colours[PAINT_LOCATIONS.BASE])
                .attr("stroke","none")

            const corners = CORNERS.map(corner=>tileGroups
                .append("path")
                .attr("d",d=>d.corners[corner])
                .attr("fill",d=>d.colours[corner])
                .attr("stroke","none")
            )

            const arcs = CORNERS.map(arc=>tileGroups
                .append("path")
                .attr("d",d=>d.arcs[arc])
                .attr("fill","none")
                .attr("stroke","white")
            )

            const centers = tileGroups
                .append("circle")
                .attr("r",d=>d.centerCircleRadius)
                .attr("cx",d=>d.cx)
                .attr("cy",d=>d.cy)
                .attr("fill",d=>d.colours[PAINT_LOCATIONS.CENTER])

            const text = tileGroups
                .filter(d=>d.text)
                .append("text")
                .attr("alignment-baseline","central")
                .attr("text-anchor","middle")
                .attr("font-family","sans-serif")
                .attr("font-weight","bold")
                .attr("x",TILE_SIZE/2)
                .attr("y",TILE_SIZE/2)
                .attr("fill",d=>d.colours[PAINT_LOCATIONS.TEXT])
                .attr("font-size",`${TILE_SIZE/4}px`)
                .text(d=>d.text)

            const redraw = () =>{
                // Smoothly interpolate camera position
                cameraX += (targetCameraX - cameraX) * 0.1;
                cameraY += (targetCameraY - cameraY) * 0.1;

                // Check for recycling
                const bufferX = TILE_SIZE; 
                const bufferY = TILE_SIZE;
                
                // Calculate visible bounds in logical coordinates
                const minLogicalX = Math.floor((cameraX - bufferX) / TILE_SIZE);
                const maxLogicalX = Math.floor((cameraX + width + bufferX) / TILE_SIZE);
                const minLogicalY = Math.floor((cameraY - bufferY) / TILE_SIZE);
                const maxLogicalY = Math.floor((cameraY + height + bufferY) / TILE_SIZE);

                let anyDirty = false;

                tiles.forEach(tile => {
                    // Check if tile is too far left
                    if (tile.ix * TILE_SIZE - cameraX < -bufferX * 2) {
                        tile.init(tile.ix + TILES_PER_ROW, tile.iy);
                    }
                    // Check if tile is too far right
                    else if (tile.ix * TILE_SIZE - cameraX > width + bufferX) {
                        tile.init(tile.ix - TILES_PER_ROW, tile.iy);
                    }
                    
                    // Check if tile is too far up
                    if (tile.iy * TILE_SIZE - cameraY < -bufferY * 2) {
                        tile.init(tile.ix, tile.iy + TILES_PER_COLUMN);
                    }
                    // Check if tile is too far down
                    else if (tile.iy * TILE_SIZE - cameraY > height + bufferY) {
                        tile.init(tile.ix, tile.iy - TILES_PER_COLUMN);
                    }

                    if (tile.dirty) anyDirty = true;
                });

                // Update positions of all tiles (using transform)
                tileTranslations
                    .attr("transform", d => `translate(${d.x},${d.y})`);

                if (anyDirty) {
                    // Update visuals for dirty tiles only
                    tileRotations
                        .filter(d => d.dirty)
                        .attr("transform", d => `rotate(${d.rotation})`);
                    
                    bases.filter(d => d.dirty).attr("fill", d => d.colours[PAINT_LOCATIONS.BASE]);
                    
                    centers
                        .filter(d => d.dirty)
                        .attr("r", d => d.centerCircleRadius)
                        .attr("cx", d => d.cx)
                        .attr("cy", d => d.cy)
                        .attr("fill", d => d.colours[PAINT_LOCATIONS.CENTER]);

                    corners.forEach((cornerGroup, index) => {
                        cornerGroup
                            .filter(d => d.dirty)
                            .attr("d", d => d.corners[index])
                            .attr("fill", d => d.colours[index]);
                    });

                    arcs.forEach((arcGroup, index) => {
                        arcGroup.filter(d => d.dirty).attr("d", d => d.arcs[index]);
                    });

                    text
                        .filter(d => d.dirty)
                        .text(d => d.text)
                        .attr("fill", d => d.colours[PAINT_LOCATIONS.TEXT]);
                    
                    // Mark all dirty tiles as clean
                    tiles.forEach(tile => {
                        if(tile.dirty) tile.markClean();
                    });
                }
            }
            
            const animate = () => {
                redraw();
                requestAnimationFrame(animate);
            };
            
            // Start animation loop
            animate();

            // Keep the random tickle
            setInterval(()=>{
                tiles.forEach(tile => {
                    // Only tickle if visible to save perf? Or just tickle all.
                    // Let's tickle all for now as count is small.
                    tile.tickle();
                });
                // Redraw will pick up changes on next frame
            }, 2500)
        </script>
    </body>
</html>
